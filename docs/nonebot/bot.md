# 从简单机器人开始

在此单元，我将会用我的理解来给各位解释nonebot2内部的各种组件的功能，以及使用方法。

## 制作简单机器人

### 最简机器人
开始之前，需要了解一下制作一个机器人，需要哪些步骤。

说到底，一个简单的机器人就分为3步：

1. 输入指令，传递给机器人终端
2. 处理指令，获取对应输出
3. 输出结果，终端显示给用户

那关系图也很好确认了吧：

（这里补一张示意图）

### 加个第三方
恭喜你，已经有了最初的机器人模型，在这个模型中，只有2个成员：我和机器人。
我直接发送指令给机器人，机器人收到我的指令处理命令，然后返回结果给我，这是显而易见的。
让我们把这个模型拓展一下：
假如你想利用第三方app（比如QQ）来进行通讯，会变成什么样子：

1. 输入QQ消息（私聊，群聊）并发送
2. 机器人接收到QQ消息，并分析指令，确定调用哪些处理方式
3. 处理这个指令并返回输出消息
4. 机器人发送这个消息到QQ（私聊，群聊）


至此，我们第三方机器人流程走完了，到这个模型中，一共有3个角色：我、QQ、机器人
所以我们的沟通示意图变成了这样：

（这里补一张示意图）

### 引出gocqhttp
看，我和机器人之间多了一个桥梁-QQ（因为是第三方应用端嘛）
现在我不再直接和机器人交流了，我面对的是QQ聊天房间。我发送命令给QQ，
QQ在接收指令后将消息传递给机器人；机器人处理完结果后也不是直接发消息给我，而是将消息转发给QQ，
由QQ显示在聊天房间中。

很明显，正版QQ不会那么好心（或者说没有开放接口）将你的消息传递给你的机器人。那我们怎么办呢？
Gocqhttp就扮演了这一个角色，这是个逆向QQ协议的客户端，用他来充当你和机器人沟通的桥梁，
这时我们的模型就变成了这样：

（这里补一张示意图）

### nonebot2的定位
gocq扮演了中间人的角色，那Nonebot2是什么，答案呼之欲出了，就是这个“机器人”。所以最终，我们的机器人模型
就是下面：

（这里补一张示意图）

## Nonebot2组件
现在你清楚了Nonebot2的定位了，他就是个**接收命令-处理命令-返回结果**的后端，那他由哪些组件构成呢？这里给出
nonebot2的各种组件名称及简要说明，详细的内容我们将在后面展开：
 - **Driver**：后端驱动，用来接收消息和发送消息
 - **Adapter**：适配器，用来将消息转化成Event，同时将发送的消息交给Driver
    - Bot：机器人实例，每个连接的客户端都会实例成Bot，至此可以一个后端管理多个机器人
    - Event：事件，收到的客户端消息将会转换成事件，由此来响应各个Matcher
    - Message：消息抽象，我们接收和发送的指令都会变成Message
    - Permisson：内置权限，Adapter内置的少部分权限功能，可以即开即用
 - **Plugin**：插件，封装一系列的Mathcer，组成一个插件，用来完成特定功能
 - **Matcher**：响应器，能响应特定的事件（Event），用来处理各个命令，返回结果
    - Rule：规则，只有满足所有规则的Matcher才会在此Event触发
    - Permission：权限，满足规则后，需要检测权限，不满足也不会触发
    - handlers：处理函数，满足所有检查后就会运行这里的处理函数
 - **Config**：配置，Nonebot2的配置，采用key = value 形式，可以任意添加
